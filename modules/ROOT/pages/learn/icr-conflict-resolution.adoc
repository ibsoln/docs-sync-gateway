= Conflict Resolution in Inter-cluster Replication
:page-partial:
:page-layout: article
:page-status: {release-status-sgw} -- {release-comments-sgw}
:page-edition: Under Development
:page-role: panes
:description: This content covers conflict resolution in inter-cluster replication (replication between Sync Gateway clusters)
:keywords:

include::partial$_std-hdr-sgw.adoc[]
include::partial$block-authors-notes.adoc[tag=wip]
:topic-group: Inter-cluster Replication
:param-related: {xref-sgw-pg-config-properties} | {xref-sgw-pg-rest-api-admin}
:param-abstract: Inter-cluster replication conflict resolution policies and behaviors.
include::partial$block-abstract.adoc[]


:fn-no-op-text: footnote:fn-1[No-op update -- refers to a change to the document body that has no impact on the app logic but will trigger an import by the Sync Gateway. One option could be to include a property used specifically for this purpose (i.e. a counter that can be incremented in response to conflict resolver errors).]

:fn-no-op: footnote:fn-1[]

ifeval::["{releaseStatus}" == "gamma"]
[.pane__frame--orange]
.Author's Notes
--
Information sources include:

* https://issues.couchbase.com/browse/DOC-6465
* https://docs.google.com/document/d/13E6JOq8u_AaUd_t8FZEPCAuq7jfkjryecjBQBHE3pG8/edit?ts=5e7cd22f#heading=h.ho0j9x72yi1l
--
endif::[]

// Useful resources: https://blog.couchbase.com/document-conflicts-couchbase-mobile/[blog-- Document Conflicts and Automatic Conflict Resolution] | https://blog.couchbase.com/conflict-resolution-couchbase-mobile/[blog-- Demystifying Conflict Resolution] | https://blog.couchbase.com/tag/conflict-resolution/[Blog category -- Conflict Resolution] |{xref-sgw-pg-resolving-conflicts}

== Overview
// tag::overview[]
Sync Gateway's inter-cluster replication supports automatic conflict resolution to resolve conflicting document changes (revisions).
It delivers this using a flexible policy-driven mechanism, which automatically detects and resolves document conflicts under replication.

A set of conflict resolver policies are available out-of-the-box. They can be easily applied to Sync Gateway replications to give automatic resolution.

As soon as the _active_ Sync Gateway database detects a conflict in a replicated document revision, it applies the specified resolver policy. This policy assesses the conflicting revisions and either determines the winning revision or returns an error if it fails while doing so.
// end::overview[]

See: <<resolver-policies, conflict resolver policies>>

== Automatic Conflict Resolution

When an active Sync Gateway database detects a conflict in replicated document revisions, it calls and applies its configured <<resolver-policies, resolver policy>> to determine a _winning_ revision.
It will return an error if this process fails.

When a passive Sync Gateway database detects a conflict it responds to the active with a `409` response and rejects the revision. The active Sync Gateway will then apply its specified conflict resolver policy.

The default automatic resolution policy always returns a winner determined by the following rules:
// * Deletes always win.

* If one revision is a delete (tombstone), that is the winner.
* If both revisions are deletes then the delete with the longest revision history (most revisions) wins. In short the delete with the highest revision Id wins.
* If neither revision is a delete then the revision with the longest revision history (most revisions) wins.
* Configured using: `"conflict_resolution_type": "useDefault"`.
//  even when the no-conflicts mode is enabled (that is where xref:config-properties.adoc#databases-foo_db-allow_conflicts["allow_conflicts": false]).

// When running two Sync Gateway clusters with the no-conflicts mode enabled, cross-cluster document conflicts will result in that document no longer being replicated. To avoid this, the application must ensure that concurrent cross-cluster updates are not made to a given document.

// Deployments  must implement a custom conflict resolver in an external app as specified in {xref-sgw-pg-resolving-conflicts}.

{enterprise}::
A _custom_ resolver policy is available.
It provides additional flexibility allowing users to provide their own resolution logic -- see <<custom-conflict-resolution-ee, Custom Conflict Resolver>>.

== Resolver Policies

Conflict resolution is configurable, in that you can choose to apply one of the out-of-the-box (predefined) conflict resolver policies.

[#predefined-resolver-policies]
// .Predefined resolver policies
// The following automatic conflict resolution policies are available when configuring a replication:

Default::
Applies the default policy described in <<automatic-conflict-resolution>>

Local Wins::
* Always considers the local change the winner.
* Configured using: `"conflict_resolution_type": "localWins"`

Remote Wins::
Always considers the remote change the winner.
* Configured using: `"conflict_resolution_type": "remoteWins"`

== How Resolution Works

Pull Replications::
+
--
For _Pull_ replications the _active_ Sync Gateway is responsible for detecting and resolving conflicts based on the configured _conflict_resolution_type_ (see configuration item: {xref-sgw-pg-config-properties-db-rep-conflict}.

This is also how conflicts are handled when Couchbase Lite clients pull down documents to Sync Gateway.

*Note:* Resolved conflicts are only transferred from active to passive Sync Gateways if a replication is setup between them.
--

Push Replications::
+
--
Passive Sync Gateway::
The _passive_ Sync Gateway will automatically detect and reject conflicting revisions being _pushed_ to it.
+
Note that conflicts are not resolved.
The revision is rejected and the document returned -- with a `409 Conflict` -- response to the active Sync Gateway.

Active Sync Gateway::
It is  the responsibility of the active sync Gateway to address rejected revisions in accordance with its specified _conflict_resolution_type_.
--
+
This approach is the same as that adopted when Couchbase Lite clients push documents to Sync Gateway.

== Configuring a Policy to Use
To invoke automatic conflict resolution, simply specify the required policy in the replication definition.
The specified conflict resolver policy will be applied by the active Sync Gateway whenever a conflict is detected during replication.

.Using automatic conflict resolution
=====
[{tabs}]
====

default::
+
--
[source, json]
----
"databases:"
  // other config as necessary
  "this_db:"
    // other config as necessary
    "sgreplicate_enabled": "true",
    "replications": [
        {
          "replication_id": "replication1",
          "direction": "pushAndPull",
          "continuous": true,
          "filter": "sync_gateway/bychannel",
          "query_params": [
              "channel1",
              "channel2"
          ],
          "conflict_resolution_type": "default",
          // other config as necessary
        }
    ]
// other config as necessary
----
--

localWins::
+
--
[source, json]
----
"databases:"
  // other config as necessary
  "this_db:"
    // other config as necessary
    "sgreplicate_enabled": "true",
    "replications": [
        {
          "replication_id": "replication1",
          "direction": "pushAndPull",
          "continuous": true,
          "filter": "sync_gateway/bychannel",
          "query_params": [
              "channel1",
              "channel2"
          ],
          "conflict_resolution_type": "localWins",
          // other config as necessary
        }
    ]
// other config as necessary
----
--

remoteWins::
+
--
[source, json]
----
"databases:"
  // other config as necessary
  "this_db:"
    // other config as necessary
    "sgreplicate_enabled": "true",
    "replications": [
        {
          "replication_id": "replication1",
          "direction": "pushAndPull",
          "continuous": true,
          "filter": "sync_gateway/bychannel",
          "query_params": [
              "channel1",
              "channel2"
          ],
          "conflict_resolution_type": "remoteWins",
          // other config as necessary
        }
    ]
// other config as necessary
----

--


====
=====
// SG-Replicate 2.0 supports automatic conflict resolution to resolve conflicting document revisions.

// The automatic conflict resolution policy is the same as that adopted in Couchbase Lite 2.x between Couchbase Lite and Sync Gateway.
// The basic rules being:

// include::couchbase-lite:ROOT:partial$handling-conflicts.adoc[tags=auto-conflict-resolution]

== Custom Conflict Resolution [EE]

{enterprise}

_In this section_: <<conflict-resolution-approaches>>  |  <<approaches-to-error-handling>>  |  <<conflict-resolver-structure>>

Custom conflict resolution is handled by the _active_ Sync Gateway using a user-provided _custom conflict resolver_. This Javascript function is embedded in the replication configuration.

The predefined conflict resolver policies are also available as Javascript functions that you can call from within that _custom_conflict_resolver_ function

You can invoke the non-custom built-in resolver policies from within your resolver function. This is useful when you want to apply greater selectivity to the automatic conflict resolution process. For example, you want to apply the `remoteWins` policy only for a specific type of document - see <<use-policies, Use Policies>> tab in <<simple-conflict-resolvers>>.

=== Conflict Resolution Approaches

There are two ways to handle conflicts in your custom_conflict_resolver, you can either:

* Choose a _winning_ revision from among the conflicting revisions (see <<simple-conflict-resolvers>>), or
* Merge conflicting revision to create a new _winning_ revision; losing revisions are tomb-stoned.
+
However, user are cautioned against using complex resolver logic as it can have a significant impact on performance.

=== Approaches to Error Handling

// tag::overview-error-handling[]
The custom conflict resolver function should not terminate the replication when it encounters exceptions or errors _pull_ replication.
Instead it should provide sufficient information to aid troubleshooting and recovery.

For example, your custom conflict resolver function should:

* Skip the document causing the issue
* Log a suitable warning level message.
Include at least the skipped document's Id and the sequence Id of the revision in error.
// end::overview-error-handling[]

Refer to log files when troubleshooting conflict resolution errors, to identify the document id and revision sequence in error.

.Some Error Scenarios and Recommended Resolutions
====

Unexpected data in the remote document::
You should update the remote document to fix the issue.
Doing so will cause replication of the update.

Unexpected data in the local document::
You should update the local document to fix the issue.
This will not trigger a pull-replication.
Do a no-op-update {fn-no-op-text} of the remote document, which will trigger replication and conflict resolution.

Fault in conflict resolution javascript function::
+
--
Fix the Javascript logic and then either:

* Do a _no op update_ {fn-no-op} of the remote document.
This triggers a pull replication and subsequent conflict resolution.

* Reset the replication (using `_replicationstatus/reset` endpoint). Not recommended as it introduces significant duplicate processing in re-syncing previously synced documents.

--
====


=== Conflict Resolver Structure

[source, javascript]
----
//
function (local, remote) { // <.>
	// TODO: Determine winner using built-in or custom policy
	return { // <.>
		body: winner.body,
		meta: winner.meta
	}; // Return winning revision
}
----

<.> *Parameters*
+
--
local::
This _local_ object encapsulates the body and metadata of the local conflicting document revision being replicated. Its content matches the JSON stored at the local Sync Gateway.
+
remote::
The _remote_ object, encapsulates the body and metadata of the remote conflicting document revision being replicated. Its content matches the JSON stored at the remote Sync Gateway.
--

<.> *Return object*
+
--
body::
Set the _body_ object of the winning document revision to contain the _body_ content of the JSON body of either the local, or remote, document revisions.
+
meta::
This is the Metadata of the winning document revision. Set it to the content of the JSON body of either the local, or remote, document metadata.
--

=== Sample Conflict Resolvers

[#simple-conflict-resolvers]
.Simple conflict resolvers
=====
[{tabs}]
====
[#use-policies]
Use Policies::
+
--
This example uses the built-in resolver functions to resolve the conflict based-on the document type.

So, documents of type `a-doc-type-1` are always resolved in favor of the remote revision. All other document types are resolved in accordance with the default resolver policy.

[source,json]
----
include::{example-cfg}[tags=icr-simple-conflict-resolver, indent=0]
----
--

Nominate a Winner::
+
--
This example selects a winner based on relative priorities and builds a return response of its own rather than using either the localWins or remoteWins policy, although it does rely on the default resolver policy as a backstop.

[source,json]
----
include::{example-cfg}[tags=icr-simple-own-winner-conflict-resolver, indent=0]
----
--
Merge a Winner::
+
--
This example creates a winner by merging changes from the local and remote documents to create a new document object, which is returned as the winner.

If both document.types are non-null and the local document.type is `usedefault`, the merge path is overridden and the default resolver policy is applied.

[source,json]
----
include::{example-cfg}[tags=icr-simple-merge-conflict-resolver, indent=0]
----
--
=====

include::partial$block-related-content-icr.adoc[]