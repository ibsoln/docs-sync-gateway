// BEGIN -- PAGE -- sync-function.adoc
// BEGIN PAGE DEFINITION
//  LOCATION modules/ROOT/pages/
//  PURPOSE:
//    This is a standard content presentations page.
//    Its name/title identify the content/topic
//  PARAMETERS:
//    None
//  INCLUSION USAGE --
//    This module uses attributes from:
//    - /modules/ROOT/pages/_partials/_page-index.adoc -- xref page links
//
//    This module uses these inclusions:
//    - /modules/ROOT/pages/_partials/_std-hdr-sgw.adoc -- std attribute environment
//    - /modules/ROOT/pages/_partials/block-abstract.adoc --  std text block for page header content
//    - /modules/ROOT/pages/_partials/block-related-content-deploy.adoc --  std text block for page footer content
//    - /modules/ROOT/pages/_partials/common-cfg-ext-javascript.adoc --  for javascript function examples
//    /modules/ROOT/pages/_partials/sync-function-ovw.adoc
//    - modules/ROOT/assets/images -- .png/.jpeg images
//    /modules/examples/sync-gateway-config.json -- examples
//  INCLUSION USAGE
// END PAGE DEFINITION
= Sync Function API Reference
:page-aliases: advance/adv-sgw-cfg-sync-function.adoc
:page-layout: article
:page-partial:
:description: pass:q[Use Sync Functionss to implement effective data routing and access control in the cloud-to-edge synchronization of enterprise data.]
:idprefix:
:idseparator: -


include::partial$_std-hdr-sgw.adoc[]


// BEGIN - page attributes
:ouroffset: +1
// END - page attributes


// BEGIN -- Page Heading
:param-topic-group: access-control
:param-abstract: pass:q[The Sync Function is crucial to the security of data sync and replication. It is in charge of data validation, access control and routing. This topic provides a reference resource on Sync and its helper functions.]
include::partial$block-abstract.adoc[]
// END -- Page Heading


== Introduction

include::{concepts}sync-function.adoc[leveloffset={ouroffset}]


== Arguments
The sync function arguments are:

`doc`::
This object references the content of the document that is being saved.
It matches the JSON saved by the Couchbase Lite and replicated to Sync Gateway.
* The `_id` property contains the document ID
* The `_rev` property is the new revision ID.
* If the document is being deleted, there will be a `_deleted` property with the value true.

`oldDoc`::
If the document has been saved before, the revision that is being replaced is available in this argument.
Otherwise it's `null`.
(In the case of a document with conflicts, the current provisional winning revision is passed in `oldDoc`.) +
Your implementation of the sync function can omit the `oldDoc` parameter if you do not need it (JavaScript ignores extra parameters passed to a function).

If you don't supply a sync function, Sync Gateway uses the {configuration-schema-static--pfx}#databases-this_db-sync[default Sync Function].

If you want to access control data embedded in Sync Gateway document metadata you should set:

* {configuration-schema-database--xref-enable-shared-bucket-access} = `true`
* {configuration-schema-database--xref-user-xattr-key} = a valid, and existing, extended attribute name

Doing so will then expose an additional, optional argument, `meta`.

The `meta` object references an XATTR key designated as identifying access control and-or routing information -- see {using-xattr-access-grants--xref}
You can see a simple example of its use in <<ex-xattr-access-grant>>.

[#ex-xattr-access-grant]
.Access Grants using Xattr
====
include::{examples-lib}[tags="syncfunc-args"]

====


// == Operation

// // tag::overview[]
// The Sync Function is executed every time a new revision/update is made to a document.
// The changes to channels and access made by the sync function are _tied to that revision_.
// If the document is later updated, the sync function will be called again on the new revision, and the new channel assignments and user/channel access _replace_ the ones from the first call.

// // end::overview[]
// It can do the following things:

// * Grant user access to channels -- see: {access-grants--xref}
// * Validate documents -- see: <<link TBD>>
// * Authorize changes -- see: {access-grants--xref-control-write-access}
// * Assign documents to channels -- see: {channels-xref}
// // xref:write-access.adoc#data-validation[Write Access -- data validation]
// // xref:write-access.adoc#write-access[Write Access -- authorize the change]
// // xref:read-access.adoc#add-access[Read Access -- add access]

// For simple applications it might be the only server-side code you need to write.
// For more complex applications it is still a primary touchpoint for managing data routing and access control.


[#lbl-access]
== access()

include::partial$sync-api/sync-function-api-access.adoc[leveloffset={ouroffset}]

[#lbl-channel]
== channel()

include::partial$sync-api/sync-function-api-channel.adoc[leveloffset={ouroffset}]
// [#lbl-access]
// == access(username, channelname)

// Documents can grant users access to channels.

// The `access()` function grants access to a channel to a specified user.
// It can be called multiple times from a sync function.

// The first argument can be an array of strings, in which case each user in the array is given access.
// The second argument can also be an array of strings, in which case the user(s) are given access to each channel in the array.
// As a convenience, either argument may be `null` or `undefined`, in which case nothing happens.

// TIP: If a user name begins with the prefix `role:`, the rest of the name is interpreted as a role rather than a user.
// The call then grants access to the specified channels for all users with that role.

// You can use the _all channels_ wildcard ('***') to grant the user access to all documents in all channels.

// The effects of all access calls by all active documents are effectively combined in a union, so if _any_ document grants a user access to a channel, that user has access to the channel.

// NOTE: Calling `access(username, channelname)` multiple times to grant the same user access to the same channel will result in negative performance implications.

// .access(username, channel)
// ====
// This example shows some valid ways to call `access()`:

// [source,javascript]
// ----
// access ("jchris", "mtv"); // <.>
// access ("jchris", ["mtv", "mtv2", "vh1"]); // <.>
// access (["snej", "jchris", "role:admin"], "vh1"); // <.>
// access (["snej", "jchris"], ["mtv", "mtv2", "vh1"]); // <.>
// access (null, "hbo");  // <.>
// access ("snej", null);
// ----
// <.> Allow access of single channel to single user
// <.> Allow access of multiple channels to single user
// <.> Allow access of single channel to multiple users
// <.> Allow access of multiple channels to multiple users
// <.>  These are no-ops
// ====


[#lbl-role]
== role()

include::partial$sync-api/sync-function-api-role.adoc[leveloffset={ouroffset}]

// Use the `role()` function to add a role to a user.
// This indirectly gives them access to any channels assigned to that role.

// NOTE: Roles, like users, have to be explicitly created by an administrator.

// This function affects the user's ability to revise documents, if the access function requires role membership to validate certain types of changes.
// Its use is similar to `access` -- the value of either parameter can be a string, an array of strings, or null.
// If the value is null, the call is a no-op.

// For consistency with the `access` call, role names must always be prefixed with `role:`.
// An exception is thrown if a role name doesn't match this.
// Some examples:

// .role(username, rolename)
// ====
// [source,javascript]
// ----
// role ("jchris", "role:admin");
// role ("jchris", ["role:portlandians", "role:portlandians-owners"]);
// role (["snej", "jchris", "traun"], "role:mobile");
// role ("ed", null);  // no-op
// ----
// ====

// Nonexistent roles don't cause an error, but have no effect on the user's access privileges.

// TIP: You can create roles retrospectively.
// As soon as a role is created, any pre-existing references to it take effect.


[#lbl-require-user]
== requireUser()

include::partial$sync-api/sync-function-api-require-user.adoc[leveloffset={ouroffset}]

// Use the `requireUser()` function to reject document updates that are not made by the specified user or users, as shown in the <<ex-requireuser>>.

// [#ex-requireuser]
// .requireUser(username)
// ====
// [source,javascript]
// ----
// // Throw an error if username is not "snej":
// requireUser("snej");

// // Throw an error if username is not in the list:
// requireUser(["snej", "jchris", "tleyden"]);
// ----
// ====

// The function signals rejection by throwing an exception, so the rest of the sync function will not be run.

// Treat all properties of the `doc` parameter as _untrusted_; this *is* the object that you're validating.
// This may sound obvious, but it can be easy to make mistakes, like calling `requireUser(doc.owners)` instead of `requireUser(oldDoc.owners)`.
// When using one document property to validate another, look up that property in `oldDoc`, not `doc`!


[#lbl-require-role]
== requireRole()

include::partial$sync-api/sync-function-api-require-role.adoc[leveloffset={ouroffset}]


// Use the `requireRole()` function to reject document updates that are not made by user with the specified role or roles, as shown in <<ex-requirerole>>.

// [#ex-requirerole]
// .requireRole(rolename)
// ====

// [source,javascript]
// ----
// // Throw an error unless the user has the "admin" role:
// requireRole("admin");

// // Throw an error unless the user has one or more of those roles:
// requireRole(["admin", "old-timer"]);
// ----
// ====

// The argument may be a single role name, or an array of role names.
// In the latter case, the user making the change must have one or more of the given roles.

// The function signals rejection by throwing an exception, so the rest of the sync function will not be run.


[#lbl-require-access]
== requireAccess()

include::partial$sync-api/sync-function-api-require-access.adoc[leveloffset={ouroffset}]


// Use the `requireAccess()` function to reject document updates that are not made by the a user with access to at least one of the given channels, as shown in <<ex-requireaccess>>

// The function signals rejection by throwing an exception, so the rest of the sync function will not be run.

// You can specify multiple channel names, for example: +
// `requireAccess('any channel name', '*')'`


// [#ex-requireaccess]
// .requireAccess(channels)
// ====
// [source,javascript]
// ----
// // Throw an exception unless the user has access to read the "events" channel:
// requireAccess("events");

// // Throw an exception unless the user can read one of the channels in the
// // previous revision's "channels" property:
// if (oldDoc) {
//     requireAccess(oldDoc.channels);
// }
// ----
// ====

// NOTE -- requireAccess() will only recognize grants made explicitly using a channel name (not by wildcard).
// So, if a user was granted access using only the xref:{sgw-pg-channels}#lbl-all-channels[all channels wildcard]] (`+*+`), then `requireAccess('any channel name')'` will fail because the user wasn't granted access to that channel (only to the `+*+` channel).


[#lbl-require-admin]
== requireAdmin()

include::partial$sync-api/sync-function-api-require-admin.adoc[leveloffset={ouroffset}]

// Use the `requireAdmin()` function to reject document updates that are not made by the Sync Gateway Admin REST API.

// [ex-requireadmin]
// .requireadmin
// ====
// [source,javascript]
// ----
// // Throw an exception unless the request is sent to the Admin REST API
// requireAdmin();
// ----
// ====

[#lbl-throw]
== throw()

include::partial$sync-api/sync-function-api-throw.adoc[leveloffset={ouroffset}]

// You enforce the validity of document structure by checking the necessary constraints and throwing an exception if they're not met.

// Use `throw()` to prevent a document from persisting or syncing to any other users by including an error object containing the `forbidden`: property -- see <<>>

// [#ex-throw]
// .throw(forbidden:)
// ====
// In this example the sync function disallows all writes to the database it is in.

// [source,javascript]
// ----
// function(doc) {

//    throw({forbidden: "read only!"}) // <.>

// }
// ----

// The document update will be rejected with an HTTP 403 "Forbidden" error code, with the value of the `forbidden:` property being the HTTP status message.
// This is the preferred way to reject an update.

// ====

// In validating a document, you'll often need to compare the new revision to the old one, to check for illegal changes in state.
// For example, some properties may be immutable after the document is created, or may be changeable only by certain users, or may only be allowed to change in certain ways.
// That's why the current document contents are given to the sync function, as the `oldDoc` parameter.

// We recommend that you not create invalid documents in the first place.
// As much as possible, your app logic and validation function should prevent invalid documents from being created locally.
// The server-side sync function validation should be seen as a fail-safe and a guard against malicious access.


[#lbl-expiry]
== expiry()

include::partial$sync-api/sync-function-api-expiry.adoc[leveloffset={ouroffset}]

// Calling `expiry(value)` from within the sync function will set the expiry value (TTL) on the document.

// .expiry(value)
// ====
// [source,javascript]
// ----
// expiry("2018-07-06T17:00:00+01:00")
// ----
// ====

// Under the hood, the expiration time is set and managed on the Couchbase Server document (TTL is not supported for databases in walrus mode). The value can be specified in two ways:

// * *ISO-8601 format:* for example the 6th of July 2016 at 17:00 in the BST timezone would be `2016-07-06T17:00:00+01:00`;
// * *as a numeric Couchbase Server expiry value:* Couchbase Server expiries are specified as Unix time, and if the desired TTL is below 30 days then it can also represent an interval in seconds from the current time (for example, a value of 5 will remove the document 5 seconds after it is written to Couchbase Server).
// The document expiration time is returned in the response of GET xref:{rest-api--page}#/document/get\__db___doc_[+/\{tkn-db}/\{doc}+] when `show_exp=true` is included in the querystring.

// The behavior on the resulting document when the expiry value is reached depends on the following:

// if xref:shared-bucket-access.adoc[Mobile-Web Data Sync] is enabled::
// The *active* revision of the document is tombstoned.
// If there is another non-tombstoned revision for this document (i.e a conflict) it will become the active revision.
// The tombstoned revision will be purged when the server's metadata purge interval is reached.
// if xref:shared-bucket-access.adoc[Mobile-Web Data Sync] is disabled::
// The document will be purged from the database.

// As with the existing explicit purge mechanism, this applies only to the local database; it has nothing to do with replication.
// This expiration time is not propagated when the document is replicated.
// The purge of the document does not cause it to be deleted on any other database.



// BEGIN -- Page Footer
include::partial$block-related-content-sync.adoc[]
// END -- Page Footer


// END -- PAGE -- sync-function.adoc
