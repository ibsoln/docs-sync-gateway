= Access Control
// BEGIN -- PAGE -- access-control.adoc
// BEGIN PAGE DEFINITION
//  LOCATION modules/ROOT/pages/
//  PURPOSE:
//    This is a standard content presentations page.
//    Its name/title identify the content/topic
//  PARAMETERS:
//    None
//  INCLUSION USAGE --
//    This module uses attributes from:
//    - /modules/ROOT/pages/_partials/_page-index.adoc -- xref page links
//
//    This module uses these inclusions:
//    - /modules/ROOT/pages/_partials/_std-hdr-sgw.adoc -- std attribute environment
//    - /modules/ROOT/pages/_partials/block-abstract.adoc --  std text block for page header content
//    - /modules/ROOT/pages/_partials/block-related-content-deploy.adoc --  std text block for page footer content
//    - modules/ROOT/assets/images -- .png/.jpeg images
//  INCLUSION USAGE
// END PAGE DEFINITION
:description: How to implement Sync Gateway access controls in the Sync Function using access grants, users, roles and channels

include::partial$_std-hdr-sgw.adoc[]

// BEGIN -- Page Attributes
:rest-api-admin-role-post--xref: {rest-api-admin--pfx}#/role/post__db___role[/\{tkn-db}/_role/]
:rest-api-admin-role-put--xref: {rest-api-admin--pfx}#/role/put__db___role__name_[/\{tkn-db}/_role/\{name}]
:rest-api-admin-user-post--xref: {rest-api-admin--pfx}#/user/post\__db___user_[/\{tkn-db}/_user]
:rest-api-admin-user-put--xref: {rest-api-admin--pfx}#/user/post\__db___user_[/\{tkn-db}/_user/\{name}]


:SGW: pass:q[_Sync Gateway_]
:channel1: pass:q,a[_Channel #1_]
:channel2: pass:q,a[_Channel #2_]
:channel3: pass:q,a[_Channel #3_]

:Edge1: pass:q,a[_Edge #1_]
:Edge2: pass:q,a[_Edge #2_]
// END -- Page Attributes


:param-topic-group: access-control
:param-abstract: pass:q[The sync function API provides several methods that you can use to validate and control user access to databases and documents.]
include::partial$block-abstract.adoc[]


== Introduction

In the Couchbase Mobile ecosystem, every {user--xref} and {role--xref} is granted access to zero, one or more {channels--xref}.
It is this channels list that determines the documents users can access -- as illustrated in <<img-access-control-model>>

A user can only read documents that are in at least one of their assigned channels; whether directly or as part of an assigned role.

NOTE: All users can implicitly access any document in the {channels--xref-public-channel}

Once a user is granted access to a new channel, the {changes-feed--xref} will include all existing documents in that channel, even those from earlier sequences than the current request's `since` parameter.
So, the next replication pull request, will retrieve all documents to which the user now has access.


[#img-access-control-model]
.Access Control Model
image::access-control-triangle.png[,600]


== Entities and Concepts

Channels::
+
--
{channels--xref} are a key part of Sync Gateway's access control approach -- see: <<img-access-control-model>>

Every document is assigned to a channel (you can also think of these as tags).

For how to create and manage users -- see <<lbl-acc-ctl-channels>>.

--

Users::
+
--
{users--xref} granted access to a channel are able to access the documents assigned to that channel.

Users can also be assigned to zero or more roles.
A user inherits the channel access of all roles it belongs to.
This is very much like Unix groups, except that roles do not form a hierarchy.

For how to create and manage users -- see <<lbl-acc-ctl-users>>.
--

Roles::
+
--
{roles--xref} enable the grouping togethers of users with similar characteristics, which makes the management of large user populations easier.

Roles are granted access to channels.
Any user assigned a role can access any channels (and documents within those channels) the role has been granted access to.

For how to create and manage users -- see <<lbl-acc-ctl-roles>>.
--

Entity Relationships::
+
--
There is a many to many relationship between the entities, so:

* Many documents to a channel
* A document can be assigned to multiple channels
* A user can be assigned to multiple roles
* Roles and users can be granted access to multiple channels
--

Access Grants::
+
--

--


== Mechanism

There are a number of ways in which you can control document distribution and user access, both statically a dynamically; these are itemized in <<#lst1>> and illustrated in <<img-channel-access>>.

.Ways to configure access
[#lst1]
* Statically -- using the Sync Gateway Configuration File's {configuration-schema-static--xref--databases-user-admin-channels} setting
* Dynamically
** At the time of user creation with Admin REST Endpoint  {rest-api-admin-user-post--xref} using `admin_channel`
** Using the Sync Function's {sync-function-api-access-cmd--xref}.

[#img-channel-access]
====
image::channel-access-grant-all.png[,600]

<.> Documents are assigned to channel using the Sync Function's {sync-function-api-channel-cmd--xref} API.

<.> User are granted access to channel by one of the means defined in <<lst1>>
====


[#lbl-replication]
// === Replication
== Behavior

=== Sync Gateway
A user can only read documents that are in at least one of their assigned channels; whether directly or as part of an assigned role.

NOTE: All users can implicitly access any document in the {channels--xref-public-channel}

Once a user is granted access to a new channel, the {changes-feed--xref} will include all existing documents in that channel, even those from earlier sequences than the current request's `since` parameter.
So, the next replication pull request, will retrieve all documents to which the user now has access.

Revoking access to a channel means users who previously used the channel to get replicated documents will no longer see any synced updates.
However, documents already synced to the user's device are not deleted.


=== Couchbase Lite
By default, Couchbase Lite gets all the channels to which the configured user account has access.
This behavior is suitable for most apps that rely on {authentication-users--xref} and the {sync-function--xref} to specify which data to pull for each user.

Optionally, a Couchbase Lite "pull" replication can also specify a comma-separated list of channel names to receive documents from.
In this case, the replication from Sync Gateway will only pull documents tagged with those channels.
Client apps can use this ability to intelligently sync with a subset of the available documents from the database.

:param-bookmark: channels
include::partial$blocklinks-cbl.adoc[]


=== Admin REST API

The Admin REST API is for administrator use only, and hence is *not* accessible from the clients directly.
To allow users to sign up, it is recommended to have an app server sitting alongside Sync Gateway that performs the user validation, creates a new user on this API and then returns the response to the application.

Additionally, this API can be used in conjunction with a 3rd party server for the authentication process (see xref:{authentication-users--page}#custom-authentication[Custom authentication]).

Lastly, Sync Gateway supports xref:{authentication-users--page}#openid-connect[OpenID Connect authentication].
In this case, Sync Gateway can automatically create users for successfully authenticated users that don't have an already existing user in Sync Gateway.

[#lbl-acc-ctl-channels]
== Channels
// About channels


[#lbl-acc-ctl-users]
== Users
// About users
Users are one of the cornerstone concepts of {sgw} access control.
You can restrict document access to specific users and-or to users with specific roles.

As an entity it comprises a name, password, list of roles and a list of channels.

NOTE: Sync Gateway users and roles have no relationship to Couchbase Server's xref:server:learn:security/authorization-overview.adoc[RBAC (Role-base Access Control) users].


=== Create a User
Each user must be created on Sync Gateway before it can be used for access control.
You can create and-or manage users statically using the {configuration-schema-static--xref} or dynamically through the {rest-api-admin--xref}.

[{tabs}]
====

Admin Rest API::
+
--
Create a new user by sending a POST request to the Admin Rest Api `_user` endpoint ({rest-api-admin-user-post--xref}).
Update existing users by sending a PUT instead; in this case include the user name at the end of the url.

The user credentials (**username**/**password**) are passed in the request body.

[source,bash]
----
$ curl -vX POST "http://localhost:4985/mydatabase/_user/" -H
"accept: application/json" -H "Content-Type: application/json" -d
'{"name": "Edge1User", "password": "pass"}' // <.>

$ curl -vX PUT "http://localhost:4985/mydatabase/_user/Edge1User" -H
"accept: application/json" -H "Content-Type: application/json" -d
'{"name": "Edge1User", "admin_channels": ["RandomChannel"]}' // <.>
----

<.> Add new user "Edge1User", no `access_channel` or `role` is specified here.
<.> Update existing user "Edge1User" and add `access_channels` data

--

Configuration File::
+
--
Create users by hardcoding their credentials in the {configuration-schema-static--xref}.
This method is convenient for testing and to get started.
Use the *Admin REST API* for production system changes.
+
[source,json]
----
{
  "databases": {
    "mydatabase": {
      "users": { // <1>
        "GUEST": {"disabled": true},
        "Edge1User": {"password": "pass",
                      "admin_channels": ["RandomChannel"]},
      }
    }
  }
}
----

<.> {configuration-schema-static--pfx}#databases-this_db-users[databases.$db.users]

--
<.> Here we add the Edge1 role used in the example in this topic.

====


[#lbl-acc-ctl-roles-add]
=== Add Role to User

You can add and remove roles from users using either the {rest-api-admin--xref} or {configuration-schema-static--xref}.

Note that removing a role effectively revokes access to the channel that role is associated with and may mean users will lose access to required documents.

[{tabs}]
====

Admin REST API::
+
--
Add a role to an existing user by sending a PUT request to the Admin Rest API `_role` endpoint ({rest-api-admin-user-put--xref} ).

Specify the roles to be assigned in the `admin_roles` array.

[source,bash]
----
$ curl -vX PUT "http://localhost:4985/mydatabase/_user/{user}" -H
"accept: application/json" -H "Content-Type: application/json" -d
'{ "admin_roles": ["Edge1"]}' // <.>
----
<.> {user} is the user name to be updated, e.g. "Edge1User"

See also: {rest-api-admin-role-post--xref}
--

Configuration::
+
--
Add a role to a user in the configuration file.
This method is convenient for testing and to get started.
Use the *Admin REST API* for production systems.

[source,json]
----
{
  "databases": {
    "mydatabase": {
      "users": { // <.>
        "GUEST": {"disabled": true},
        "Edge1User": {"password": "pass", "admin_roles": ["Edge1"],
                      "admin_channels": ["RandomChannel"]},
        "Edge2User": {"password": "pass", "admin_roles": ["Edge2"]}
      }
    }
  }
}
----
<.> {configuration-schema-static--pfx}#databases-this_db-users-this_user-admin_roles[databases.$db.users.$user.admin_roles]
--

Sync Function::
+
--
You can also use the Sync Function's `role(username, rolename)` function to assign roles to users programmatically.

Note that both role and user must already exist.
Nonexistent roles don’t cause an error, but have no effect on the user’s access privileges.

[source, javascript]
----
role ("Edge1User", "role:Edge1");
role ("Edge2User", "role:Edge2":);
----
--

====


[#lbl-acc-ctl-roles]
== Roles
// About roles
Roles are named collections of <<lbl-acc-ctl-channels>>.
As an entity they comprises a name and a list of channels.

Any user associated with a role inherits the right to access any of the channels in the role's list.
This provides a convenient way to associate multiple channels with multiple users.

TIP:: Roles have a separate namespace from users, so it's possible to have a user and a role with the same name.


[#lbl-acc-ctl-roles-create]
=== Create Role

As with users, you create and-or manage roles using either the {rest-api-admin--xref} or {configuration-schema-static--xref}.


[{tabs}]
====

Admin Rest API::
+
--
Create a new role using the {rest-api-admin-role-post--xref} endpoint.

[source,bash]
----
$ curl -vX POST "http://localhost:4985/mydatabase/_roler/" -H
"accept: application/json" -H "Content-Type: application/json" -d
'{"name": "Edge1", "admin_channels": ["channel1", "channel3"]]}' // <.>
----

--

Configuration File::
+
--
Create users by hardcoding their credentials in the {configuration-schema-static--xref}.
This method is convenient for testing and to get started.
It is recommended to use the *Admin REST API* for production systems.

[source,json]
----
{
  "databases": {
    "mydatabase": {
      "roles": { // <.>
        "Edge1": {"admin_channels": ["channel1", "channel3"]}, // <.>
        "Edge2": {"admin_channels": ["channel2", "channel3"]},
        "GUEST": {"disabled": true}
      }
    }
  }
}
----

<.> {configuration-schema-static--pfx}#databases-this_db-users[databases.$db.users]

--
<.> Here we add the Edge1 role used in the example in this topic.

====

== Example

Consider the situation where two roles require, and are allowed, access to two distinct information flows and one shared flow -- see <<img-channels-example>>.

This can be achieved by:

. Creating two roles (Edge1 and Edge2) for the two groups of users.
+
--
Do this either by using the Admin Rest API endpoint  {rest-api-admin-role-post--xref} or statically by adding the role to the database in the {configuration-schema-static--xref}.
In either case specify that role Edge1 can access `Channel1`, Edge2 can access `Channel2`, and both roles can access & `Channel3` -- see: {access-control-how-create-roles--xref}
--

. Adding the roles to the appropriate users, again using either the configuration file or API -- see {access-control-how-add-roles-to-users--xref}

. Creating a Sync Function that

** Identifies and assigns appropriate documents to the right channel (or channels)
** Requires that any user accessing those channels has the right to do so; either directly or as in this case through a role assigned to them(Edge1 or Edge2).


[#img-channels-example]
.Access Control Example
====
This example shows three channels; one shared and two private.
Here {Edge1} and {Edge2} represent two groups of Sync Gateway users with the assigned roles Edge1 and Edge2 respectively.

image::channels-example-all.png[,600]

<.> Documents are routed to the appropriate channels by Sync Function logic
<.> The Sync Function requires users (or one of their roles) has access to the channel

====


[#lbl-sync-function]
== Grant Access

=== Methods

You can grant a user access to a channel statically by adding the appropriate channel to the user's `admin_channels` property in the {configuration-schema-static--xref}.
Alternatively you can provide that same `admin_channels` property using the admin REST API endpoint ({rest-api-admin-user-put--xref}).

However, the {sync-function--xref} is the preferred method for programmatically controlling document access and routing.
It can be programmed to derive appropriate access and routing information from document properties or, more securely, from a designated extended attribute (XATTR) -- see: {using-xattr-access-grants--xref} for how to define the XATTR.

Note that access grants neither confer, nor constrain, the *type* of access.
Instead you can explicitly implement write access controls within the Sync Function; perhaps restricting updates to specific users or roles -- for more on this see <<lbl-control-write-access>>.

=== Sync Function

The Sync Function exposes a number of helper functions to control access -- see reference information in {sync-function--xef}.
For example, to grant a user access to a channel use the {sync-function-api-access-cmd--xref} helper function in the Sync Function -- see <<ex-helper>>.

The `access()` function can also operate on roles.
If a user name string begins with `role:` then the remainder of the string is interpreted as a role name.
There's no ambiguity here, because ":" is an illegal character in a user or role name.

TIP: Because anonymous requests are authenticated as the user "GUEST", you can make a channel and its documents public by calling `access` with a username of `GUEST`.

[#ex-helper]
.Using the Access helper function
====
In this example documents with a type of `chatroom` are a shared resource that represents a membership list.
The list identifies all users (`doc.members` list ) to be allowed access to documents being sync'd using a specific "chatroom" channel.
The channel name is conveyed in a Metadata object, XATTRS.

[source,javascript]
----
function (doc, olddoc, meta) {
  if (doc.type == "chatroom") {  // <.>
    access(doc.members, // <.>
      meta.xattrs.channelXattr);  // <.>
  }
}
----
In this example:

<.> A chat room is represented by a document with a `type` property set to `chatroom`.
<.> Here the chatroom document's `members` property contains the names of all valid chatroom users.
These users need to be granted access to the chat channel
<.> Here the chat message channel is picked up from the XATTR key `channelXattr` and the 'access()' function used to grants all user in `members` access to that channel.

====


[#lbl-inspect-access]
== Inspect Access

You can use the admin REST API to see what channels a user has access to.
Issue an {rest-api-admin--pfx}#/database/get
\__db___all_docs[+/\{tkn-db}/_user/\{name}+] request.
Here's an example of the response.
The output shows that the user `pupshaw` has access to channels `all` and `hoopy`.

[source,json]
----
{
    "admin_channels": [
        "all"
    ],
    "admin_roles": [
        "froods"
    ],
    "all_channels": [
        "all",
        "hoopy"
    ],
    "name": "pupshaw",
    "roles": [
        "froods"
    ]
}
----

The `all_channels` property of a user account determines the channels a user can access.
Its value is derived from the union of:

* The user's `admin_channels` property, which is set using the Admin REST API.
* The channels the user has been granted access to by `access()` calls from sync functions invoked for current revisions of documents.
* The `all_channels` properties of any roles the user belongs to. These are themselves computed using the above rules.


// tag::write-access[]
[#lbl-control-write-access]
== Write Access

Use the Sync Function's helper functions to control who or what can make document updates.

You can require that the user making the change has a specific name, role or channel access -- as shown in <<ex-check-write-access>> -- by using any combination  of:

* {sync-function-api-require-user-cmd--xref}
* {sync-function-api-require-role-cmd--xref}
* {sync-function-api-require-channel}



[#ex-check-write-access]
.Control Write Access
====
Here the simple Sync Function validates whether the user modifying a document is a valid owner by checking if they are recorded as an owner of the old document:

[source, javascript]
----
function (doc, oldDoc, meta) {
  if (oldDoc) {
    requireUser(oldDoc.owner); // <.>
  }
  if (meta.xattr.channelxattr) {
    requireAccess(meta.xattr.channelxattr); // <.>
  } else
    {
      throw("No channel access granted")
    }
}
----
<.> If the user making the change is not an owner of the pre-change document, an exception is thrown and the update is rejected with an error.
<.> Here we check the designated xattr for the document channel(s) and require the user making the change to have access to on or more of the channels.
If the xattr is not set we throw an exception.


====

See <<ex-helpers>> for more helper function examples.

NOTE: When sending a change to Sync Gateway through the {rest-api-admin--xref}, the Sync Function executes with _admin privileges_. Calls to `requireUser`, `requireAccess` and `requireRole` will be no-ops, and will always appear successful.


[#ex-helpers]
.Helper Function examples
====
This example shows how to use some of the helper functions:

[source,javascript]
----

requireUser("snej") // <.>

requireUser(["snej", "jchris", "tleyden"]) // <.>

requireRole("admin") // <.>

requireRole(["admin", "old-timer"]) // <.>

requireAccess("events") // <.>

requireAccess(["events", "messages"]) // <.>
----
<.> throw an error if username is not "snej"
<.> throw if username is not in the list
<.> throw an error unless the user has the "admin" role
<.> throw an error unless the user has one of those roles
<.> throw an error unless the user has access to read the "events" channel
<.> throw an error unless the can read one of these channels
====


include::partial$block-related-content-sync.adoc[]

// END -- PAGE -- access-control.adoc
